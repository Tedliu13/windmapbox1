<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>貼地風場流線（DJF/JJA × Day/Night）</title>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
<style>
  html,body,#map{height:100%;margin:0}
  .panel{position:absolute;left:12px;top:12px;z-index:5;background:rgba(255,255,255,.96);
         padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.16);
         font:14px/1.5 system-ui,"Noto Sans TC";}
  .row{display:grid;grid-template-columns:92px 160px 52px;gap:8px;align-items:center;margin:6px 0}
  .row output{text-align:right;opacity:.8}
</style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <div style="font-weight:700;margin-bottom:6px">風場切換</div>
  <div>
    <label><input type="radio" name="season" value="DJF"> 冬季(DJF)</label>
    <label style="margin-left:10px"><input type="radio" name="season" value="JJA" checked> 夏季(JJA)</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="day" checked> 白天</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="night"> 夜晚</label>
  </div>

  <div style="font-weight:700;margin:8px 0 2px">參數</div>
  <div class="row">
    <label>粒子數</label>
    <input id="count" type="range" min="400" max="3000" step="100" value="1200">
    <output id="countV">1200</output>
  </div>
  <div class="row">
    <label>速度倍率</label>
    <input id="speed" type="range" min="0.2" max="1.8" step="0.05" value="0.9">
    <output id="speedV">0.90</output>
  </div>
  <div class="row">
    <label>尾跡長度</label>
    <input id="trail" type="range" min="2" max="10" step="1" value="5">
    <output id="trailV">5</output>
  </div>
</div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoidGVkbGl1IiwiYSI6ImNtMHAxMjdveDAwZWUya29sanY1c3Btc2EifQ.dGpYV4RZ4-OcpITjSKfcfg';
const STYLE_URL = 'mapbox://styles/tedliu/cm0qicaza00mf01pwfsfj3qgx';

// ---- 四份 native 風場檔 ----
const FILES = {
  DJF_day:   'wind_DJF_day_native.json',
  DJF_night: 'wind_DJF_night_native.json',
  JJA_day:   'wind_JJA_day_native.json',
  JJA_night: 'wind_JJA_night_native.json'
};
const DIR_IS_FROM = true; // 你的 native 角度/向量是「來向」，演算法會自動轉成「去向」

// ---- 地圖 ----
const map = new mapboxgl.Map({
  container: 'map',
  style: STYLE_URL,
  center: [121.0, 23.6],
  zoom: 9.2,
  pitch: 60,
  bearing: -8,
  antialias: true
});
map.setMinZoom(9);
map.setMaxZoom(15);

map.on('style.load', () => {
  enableTerrain();
  ensureLayers();
  loadFieldAndStart(currentKey());
});

// 啟用 3D 地形
function enableTerrain(){
  const st = map.getStyle();
  const demEntry = Object.entries(st.sources).find(([,s])=>s.type==='raster-dem');
  if (demEntry) {
    map.setTerrain({ source: demEntry[0], exaggeration: 4 });
    if (!map.getLayer('sky')) map.addLayer({ id:'sky', type:'sky', paint:{'sky-type':'atmosphere'} });
  }
}

// ---- UI ----
function currentKey(){
  const s = document.querySelector('input[name="season"]:checked').value;
  const t = document.querySelector('input[name="tod"]:checked').value;
  return `${s}_${t}`;
}
document.querySelectorAll('input[name="season"],input[name="tod"]').forEach(el=>{
  el.addEventListener('change', ()=> loadFieldAndStart(currentKey()));
});
['count','speed','trail'].forEach(id=>{
  const el = document.getElementById(id), out = document.getElementById(id+'V');
  const fmt = v => (id==='count' ? v : (+v).toFixed(2));
  const upd = ()=> out.textContent = fmt(el.value);
  el.addEventListener('input', upd); upd();
});

// ---- 載入 native U/V → 可插值的場 ----
async function loadUV(url){
  const raw = await fetch(url, {cache:'no-cache'}).then(r=>{
    if(!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    return r.json();
  });
  const arr = Array.isArray(raw) ? raw : (raw.data || raw);
  const uRec = arr.find(r=>r?.header?.parameterNumber===2);
  const vRec = arr.find(r=>r?.header?.parameterNumber===3);
  if (!uRec || !vRec) throw new Error('找不到 U/V 分量');

  const h = uRec.header;
  const nx=h.nx, ny=h.ny, lo1=h.lo1, la1=h.la1, dx=h.dx, dy=h.dy;
  const U=uRec.data, V=vRec.data;
  const bbox=[ lo1, la1 - ny*dy, lo1 + nx*dx, la1 ]; // [minLon,minLat,maxLon,maxLat]

  function bilerp(a00,a10,a01,a11, tx,ty){
    const a0=a00 + tx*(a10-a00);
    const a1=a01 + tx*(a11-a01);
    return a0 + ty*(a1-a0);
  }
  function sample(lon,lat){ // 回 {u,v} (m/s)，越界回 null
    const x=(lon-lo1)/dx - 0.5, y=(la1-lat)/dy - 0.5;
    if (x<0 || y<0 || x>nx-1 || y>ny-1) return null;
    const i0=Math.floor(x), j0=Math.floor(y);
    const i1=Math.min(i0+1,nx-1), j1=Math.min(j0+1,ny-1);
    const tx=x-i0, ty=y-j0;
    const idx=(jj,ii)=> jj*nx+ii;

    const u=bilerp(U[idx(j0,i0)],U[idx(j0,i1)],U[idx(j1,i0)],U[idx(j1,i1)], tx,ty);
    const v=bilerp(V[idx(j0,i0)],V[idx(j0,i1)],V[idx(j1,i0)],V[idx(j1,i1)], tx,ty);
    return {u, v};
  }
  return { header:h, bbox, sample };
}

// ---- 粒子與尾跡資料結構 ----
const STATE = {
  field: null,
  headSrc: 'heads', headLyr: 'heads-lyr',
  trailSrc: 'trails', trailLyr: 'trails-lyr',
  timer: null,
  parts: [],          // {lon,lat, age, path:[{lon,lat},...]}
  geoHeads: { type:'FeatureCollection', features:[] },
  geoTrails: { type:'FeatureCollection', features:[] }
};

function ensureLayers(){
  if (!map.getSource(STATE.headSrc))
    map.addSource(STATE.headSrc, { type:'geojson', data: STATE.geoHeads });
  if (!map.getSource(STATE.trailSrc))
    map.addSource(STATE.trailSrc, { type:'geojson', data: STATE.geoTrails });

  if (!map.getLayer(STATE.trailLyr)){
    map.addLayer({
      id: STATE.trailLyr, type:'line', source: STATE.trailSrc,
      paint:{
        'line-color': ['interpolate',['linear'],['get','spd'],
          0,'#ffffff', 2,'#bfe7ff', 5,'#7ed3ff', 8,'#44b9e6', 12,'#2b82cc', 20,'#1e4a9e'],
        'line-width': 1.5,
        'line-opacity': 0.72
      },
      layout:{ 'line-cap':'round','line-join':'round' }
    });
  }
  if (!map.getLayer(STATE.headLyr)){
    map.addLayer({
      id: STATE.headLyr, type:'circle', source: STATE.headSrc,
      paint:{
        'circle-radius': ['interpolate',['linear'],['zoom'], 9,1.2, 12,1.8, 15,2.4],
        'circle-color':  '#ffffff',
        'circle-stroke-color':'#000000',
        'circle-stroke-width': 0.4,
        'circle-opacity': 0.95,
        'circle-pitch-alignment':'map'
      }
    });
  }
}

// 產生/重生
function spawn(n, bbox){
  const [minLon,minLat,maxLon,maxLat] = bbox;
  const trailLen = +document.getElementById('trail').value|0;

  STATE.parts = new Array(n).fill(0).map(()=>({
    lon: minLon + Math.random()*(maxLon-minLon),
    lat: minLat + Math.random()*(maxLat-minLat),
    age: 300 + Math.floor(Math.random()*300),
    path: []
  }));

  STATE.geoHeads.features = STATE.parts.map((p,idx)=>({
    type:'Feature', properties:{id:idx, spd:0},
    geometry:{type:'Point', coordinates:[p.lon,p.lat]}
  }));
  STATE.geoTrails.features = STATE.parts.map(()=>({
    type:'Feature', properties:{spd:0},
    geometry:{type:'LineString', coordinates:[]}
  }));

  map.getSource(STATE.headSrc).setData(STATE.geoHeads);
  map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
}

// 積分（RK2 中點）
function advectRK2(p, dt, field){
  const s1 = field.sample(p.lon, p.lat); if (!s1) return null;
  let {u:u1, v:v1} = s1; if (DIR_IS_FROM){u1=-u1; v1=-v1;}
  const metersPerDegLat = 111320;
  const metersPerDegLon = metersPerDegLat * Math.cos(p.lat*Math.PI/180);
  const dlon1 = (u1*dt)/metersPerDegLon;
  const dlat1 = (v1*dt)/metersPerDegLat;

  const midLon = p.lon + 0.5*dlon1, midLat = p.lat + 0.5*dlat1;
  const s2 = field.sample(midLon, midLat); if (!s2) return null;
  let {u:u2, v:v2} = s2; if (DIR_IS_FROM){u2=-u2; v2=-v2;}
  const metersPerDegLon2 = metersPerDegLat * Math.cos(midLat*Math.PI/180);
  const dlon = (u2*dt)/metersPerDegLon2;
  const dlat = (v2*dt)/metersPerDegLat;

  return {lon: p.lon + dlon, lat: p.lat + dlat, spd: Math.hypot(u2,v2)};
}

// 主循環
function start(){
  stop();
  const count = +document.getElementById('count').value|0;
  spawn(count, STATE.field.bbox);

  const tick = ()=>{
    const trailLen = +document.getElementById('trail').value|0;
    const speedMul = +document.getElementById('speed').value;
    const dt = 0.08 * speedMul; // 秒；可依需求調

    const [minLon,minLat,maxLon,maxLat] = STATE.field.bbox;
    const heads = STATE.geoHeads.features, trails = STATE.geoTrails.features;

    for (let i=0;i<STATE.parts.length;i++){
      let p = STATE.parts[i];
      const nxt = advectRK2(p, dt, STATE.field);
      if (!nxt ||
          nxt.lon<minLon || nxt.lon>maxLon || nxt.lat<minLat || nxt.lat>maxLat ||
          --p.age<=0) {
        // 重生
        p.lon = minLon + Math.random()*(maxLon-minLon);
        p.lat = minLat + Math.random()*(maxLat-minLat);
        p.age = 300 + Math.floor(Math.random()*300);
        p.path.length = 0;
        heads[i].properties.spd = 0;
        heads[i].geometry.coordinates = [p.lon,p.lat];
        trails[i].properties.spd = 0;
        trails[i].geometry.coordinates = [];
        continue;
      }

      // 前進
      p.lon = nxt.lon; p.lat = nxt.lat;
      heads[i].properties.spd = nxt.spd;
      heads[i].geometry.coordinates = [p.lon, p.lat];

      // 尾跡
      p.path.push([p.lon, p.lat]);
      if (p.path.length>trailLen) p.path.shift();
      trails[i].properties.spd = nxt.spd;
      trails[i].geometry.coordinates = p.path;
    }

    map.getSource(STATE.headSrc).setData(STATE.geoHeads);
    map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
  };

  // 以 setInterval 控 FPS（更穩定）
  STATE.timer = setInterval(tick, 90);
  // 拖地圖時先暫停、結束再恢復（更順眼）
  map.on('dragstart.zoomstart', stop);
  map.on('dragend.zoomend', ()=>{ if(!STATE.timer) STATE.timer=setInterval(tick,90); });
}
function stop(){
  if (STATE.timer){ clearInterval(STATE.timer); STATE.timer=null; }
  map.off('dragstart.zoomstart', stop);
  map.off('dragend.zoomend', ()=>{});
}

// 載入指定情境並啟動
async function loadFieldAndStart(key){
  stop();
  const url = FILES[key];
  try{
    STATE.field = await loadUV(url);
    start();
  }catch(e){
    console.error('[loadField]', e);
    alert('讀取風場失敗：' + e.message);
  }
}
</script>
</body>
</html>
