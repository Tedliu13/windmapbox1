<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>貼地風場流線（DJF/JJA × Day/Night）</title>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
<style>
  html,body,#map{height:100%;margin:0}
  .panel{position:absolute;left:12px;top:12px;z-index:5;background:rgba(255,255,255,.96);
         padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.16);
         font:14px/1.5 system-ui,"Noto Sans TC";}
  .row{display:grid;grid-template-columns:92px 160px 52px;gap:8px;align-items:center;margin:6px 0}
  .row output{text-align:right;opacity:.8}

    /* 設定按鈕（左上） */
  .settings-btn{
    position:absolute; left:12px; top:12px; z-index:6;
    background:#fff; border:1px solid rgba(0,0,0,.12);
    border-radius:10px; padding:8px 12px; cursor:pointer;
    box-shadow:0 8px 20px rgba(0,0,0,.12); font:14px/1.5 system-ui,"Noto Sans TC";
  }
  .settings-btn:hover{ background:#f7f7f7 }

  /* 選單容器：預設隱藏 */
  #settingsPanel{ display:none }


  /* 右側模式地形圖例 */
  .legend{position:absolute;right:12px;top:50%;transform:translateY(-50%);z-index:5;
          background:rgba(255,255,255,.92);padding:8px;border-radius:10px;
          box-shadow:0 8px 20px rgba(0,0,0,.15)}
  .legend img{display:block;max-height:33vh;max-width:28vw;height:auto;width:auto}
  @media (max-width:640px){
    .legend img{max-height:24vh;max-width:40vw}
  }
</style>
</head>
<body>
<div id="map"></div>

<!-- 設定按鈕（預設只顯示這顆） -->
<button id="settingsBtn" class="settings-btn">⚙️ 設定</button>

<!-- 模式地形圖例（預設隱藏，由「模式地形」勾選控制） -->
<div id="terrainLegend" class="legend" style="display:none;">
  <img src="terrain_legend.png" alt="模式地形圖例">
</div>

<!-- 設定面板（預設隱藏） -->
<div id="settingsPanel" class="panel">
  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
    <div style="font-weight:700">風場切換 / 圖層 / 參數</div>
    <button id="closePanel" style="border:0;background:#f2f2f2;border-radius:8px;padding:4px 8px;cursor:pointer">關閉</button>
  </div>

  <div style="font-weight:700;margin-bottom:6px">風場切換</div>
  <div>
    <label><input type="radio" name="season" value="DJF"> 冬季(DJF)</label>
    <label style="margin-left:10px"><input type="radio" name="season" value="JJA" checked> 夏季(JJA)</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="day" checked> 白天</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="night"> 夜晚</label>
  </div>

  <div style="font-weight:700;margin:8px 0 2px">參數</div>
  <div class="row">
    <label>粒子數</label>
    <input id="count" type="range" min="4000" max="40000" step="1000" value="15000">
    <output id="countV">15000</output>
  </div>
  <div class="row">
    <label>速度倍率</label>
    <input id="speed" type="range" min="0.8" max="2" step="0.1" value="1">
    <output id="speedV">1</output>
  </div>
  <div class="row">
    <label>尾跡長度</label>
    <input id="trail" type="range" min="2" max="10" step="1" value="5">
    <output id="trailV">5</output>
  </div>

  <div style="font-weight:700;margin:8px 0 2px">圖層</div>
  <div>
    <label><input type="checkbox" id="chkTerrain"> 模式地形</label>
    <label style="margin-left:12px"><input type="checkbox" id="chkCounty"> 縣市邊界</label>
  </div>
  <div class="row" style="margin-top:4px">
    <label>模式透明度</label>
    <input id="terrainOpacity" type="range" min="0" max="1" step="0.05" value="0.85" disabled>
    <output id="terrainOpacityV">0.85</output>
  </div>
</div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoidGVkbGl1IiwiYSI6ImNtMHAxMjdveDAwZWUya29sanY1c3Btc2EifQ.dGpYV4RZ4-OcpITjSKfcfg';
const STYLE_URL = 'mapbox://styles/tedliu/cm0qicaza00mf01pwfsfj3qgx';

// 視覺速度倍率（越大越快）
const VISUAL_GAIN_BASE = 2000; 
// 顆數預設（也會由面板同步）
const SURF_COUNT_DEFAULT = 15000;
// 資料是否為「來向」(from)；false 表示直接用「去向」
const DIR_IS_FROM = false;

// 面板開/關
const $settingsBtn = document.getElementById('settingsBtn');
const $settingsPanel = document.getElementById('settingsPanel');
const $closePanel = document.getElementById('closePanel');

$settingsBtn.addEventListener('click', ()=>{
  $settingsPanel.style.display = ($settingsPanel.style.display==='block') ? 'none' : 'block';
});
$closePanel.addEventListener('click', ()=> $settingsPanel.style.display='none');

const $terrainOpacity = document.getElementById('terrainOpacity');
const $terrainOpacityV = document.getElementById('terrainOpacityV');

function syncTerrainOpacityUI(){
  if (!map.getLayer('terrain-img')) return;
  const v = map.getPaintProperty('terrain-img', 'raster-opacity') ?? 0.85;
  $terrainOpacity.value = v;
  $terrainOpacityV.textContent = (+v).toFixed(2);
  const vis = map.getLayoutProperty('terrain-img','visibility');
  $terrainOpacity.disabled = (vis !== 'visible');
}

$terrainOpacity.addEventListener('input', ()=>{
  const v = parseFloat($terrainOpacity.value);
  $terrainOpacityV.textContent = v.toFixed(2);
  if (map.getLayer('terrain-img')) {
    map.setPaintProperty('terrain-img','raster-opacity', v);
  }
});



// ---- 風場檔 ----
const FILES = {
  DJF_day:   'wind_DJF_day_native.json',
  DJF_night: 'wind_DJF_night_native.json',
  JJA_day:   'wind_JJA_day_native.json',
  JJA_night: 'wind_JJA_night_native.json'
};

// ---- 地圖 ----
const map = new mapboxgl.Map({
  container: 'map',
  style: STYLE_URL,
  center: [121.0, 23.4],
  zoom: 8.5,
  pitch: 45,
  bearing: -8,
  antialias: true
});
map.setMinZoom(7);
map.setMaxZoom(14);

map.on('style.load', async () => {
  enableTerrain();
  ensureLayers();
  await map.once('idle');                // 等樣式穩定
  await addModelTerrain();               // 模式地形（image source + raster layer，預設隱藏）
  await addCountyBoundaries();           // 縣市邊界（line），預設隱藏
  bindLayerToggles();                    // 勾選框控制顯示/隱藏
  syncTerrainOpacityUI();          // ★ 同步 slider 初值與可用狀態
  loadFieldAndStart(currentKey());       // 啟動風場貼地流線
});

// 啟用 3D 地形
function enableTerrain(){
  const st = map.getStyle();
  const demEntry = Object.entries(st.sources).find(([,s])=>s.type==='raster-dem');
  if (demEntry) {
    map.setTerrain({ source: demEntry[0], exaggeration: 4 });
    if (!map.getLayer('sky')) map.addLayer({ id:'sky', type:'sky', paint:{'sky-type':'atmosphere'} });
  }
}

// 取得一個 beforeId，保證把 overlay 放在「最後一個基底 raster/hillshade」的後面
function getOverlayAnchorId() {
  const layers = map.getStyle().layers;
  let lastBase = -1;
  for (let i = 0; i < layers.length; i++) {
    const L = layers[i];
    // 視為底圖的類型：raster（衛星/影像）、hillshade（陰影）
    if (L.type === 'raster' || L.type === 'hillshade') {
      // 排除我們自己要加的 terrain-img（第一次呼叫時通常還不存在，但保險寫一下）
      if (L.id !== 'terrain-img') lastBase = i;
    }
  }
  // 回傳「最後一個基底圖層的下一層」作為 beforeId
  return layers[lastBase + 1]?.id; // 可能是某個道路/水系/標籤圖層
}


// 取代原本的 addModelTerrain()
async function addModelTerrain(){
  if (map.getSource('terrain-img')) return;
  try {
    const jb = await fetch('terrain_bounds.json', {cache:'no-cache'}).then(r=>r.json());
    let corners; // 要餵給 image source 的四角座標：[ [tl],[tr],[br],[bl] ]

    // ★ 你的檔案長這樣：{ topleft:[lat,lon], topright:[lat,lon], bottomright:[lat,lon], bottomleft:[lat,lon] }
    if (jb && jb.topleft && jb.topright && jb.bottomright && jb.bottomleft) {
      const tl = [ jb.topleft[1],      jb.topleft[0]      ]; // [lon,lat]
      const tr = [ jb.topright[1],     jb.topright[0]     ];
      const br = [ jb.bottomright[1],  jb.bottomright[0]  ];
      const bl = [ jb.bottomleft[1],   jb.bottomleft[0]   ];
      corners = [tl, tr, br, bl];
    } else {
      // 其他相容格式：[[tl],[tr],[br],[bl]] 或 bbox {minLon,minLat,maxLon,maxLat} / {west,east,south,north}
      const b = jb.bounds || jb;
      if (Array.isArray(b) && b.length===4 && Array.isArray(b[0])) {
        corners = b;
      } else {
        const minLon = b.minLon ?? b.minX ?? b.west ?? b.w;
        const minLat = b.minLat ?? b.minY ?? b.south ?? b.s;
        const maxLon = b.maxLon ?? b.maxX ?? b.east ?? b.e;
        const maxLat = b.maxLat ?? b.maxY ?? b.north ?? b.n;
        if ([minLon,minLat,maxLon,maxLat].some(v => typeof v !== 'number')) {
          throw new Error('Unsupported terrain_bounds.json schema');
        }
        corners = [
          [minLon, maxLat], // tl
          [maxLon, maxLat], // tr
          [maxLon, minLat], // br
          [minLon, minLat]  // bl
        ];
      }
    }

    map.addSource('terrain-img', {
      type: 'image',
      url: 'terrain_land_only.png',
      coordinates: corners
    });

    const beforeId = getOverlayAnchorId();   // ★ 取得定位點
    map.addLayer({
      id: 'terrain-img',
      type: 'raster',
      source: 'terrain-img',
      layout: { visibility: 'none' },        // 預設由面板控制
      paint: { 'raster-opacity': 0.85, 'raster-resampling': 'nearest' },
      slot: 'middle'                          // 不是 top，避免壓住你的自訂圖層
    }, beforeId);

  } catch(e){
    console.error('[terrain-img]', e);
  }
}


// 縣市邊界（兩層：外黑內白）
async function addCountyBoundaries(){
  if (!map.getSource('tw-counties')) {
    try {
      const data = await fetch('taiwan_county.geojson', {cache:'no-cache'}).then(r=>{
        if(!r.ok) throw new Error('HTTP '+r.status);
        return r.json();
      });
      map.addSource('tw-counties', { type:'geojson', data });
    } catch(e){
      console.error('[counties] 載入失敗', e);
      return;
    }
  }
  if (!map.getLayer('county-casing')) {
    map.addLayer({
      id:'county-casing',
      type:'line',
      source:'tw-counties',
      slot:'top',
      layout:{ visibility:'none', 'line-join':'round','line-cap':'round' },
      paint:{
        'line-color':'rgba(0,0,0,.55)',
        'line-width':['interpolate',['linear'],['zoom'], 6,0.8, 9,1.4, 12,2.2, 14,2.8]
      }
    });
  }
  if (!map.getLayer('county-outline')) {
    map.addLayer({
      id:'county-outline',
      type:'line',
      source:'tw-counties',
      slot:'top',
      layout:{ visibility:'none', 'line-join':'round','line-cap':'round' },
      paint:{
        'line-color':'#ffffff',
        'line-width':['interpolate',['linear'],['zoom'], 6,0.5, 9,1.2, 12,1.8, 14,2.4]
      }
    });
  }
}

// 勾選框控制
function bindLayerToggles(){
  const chkTerrain = document.getElementById('chkTerrain');
  const chkCounty  = document.getElementById('chkCounty');
  const leg = document.getElementById('terrainLegend');

  if (chkTerrain) chkTerrain.addEventListener('change', ()=>{
    const vis = chkTerrain.checked ? 'visible' : 'none';
    if (map.getLayer('terrain-img')) map.setLayoutProperty('terrain-img','visibility', vis);
    if (leg) leg.style.display = chkTerrain.checked ? 'block' : 'none';
    // slider 可用/不可用
    $terrainOpacity.disabled = !chkTerrain.checked;
  });

  if (chkCounty) chkCounty.addEventListener('change', ()=>{
    const vis = chkCounty.checked ? 'visible' : 'none';
    ['county-casing','county-outline'].forEach(id=>{
      if (map.getLayer(id)) map.setLayoutProperty(id,'visibility', vis);
    });
  });
}


// ---- UI ----
function currentKey(){
  const s = document.querySelector('input[name="season"]:checked').value;
  const t = document.querySelector('input[name="tod"]:checked').value;
  return `${s}_${t}`;
}
document.querySelectorAll('input[name="season"],input[name="tod"]').forEach(el=>{
  el.addEventListener('change', ()=> loadFieldAndStart(currentKey()));
});
['count','speed','trail'].forEach(id=>{
  const el = document.getElementById(id), out = document.getElementById(id+'V');
  const fmt = v => (id==='count' ? v : (+v).toFixed(2));
  const upd = ()=> out.textContent = fmt(el.value);
  el.addEventListener('input', upd); upd();
});

// ---- 載入 native U/V → 可插值的場 ----
async function loadUV(url){
  const raw = await fetch(url, {cache:'no-cache'}).then(r=>{
    if(!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    return r.json();
  });
  const arr = Array.isArray(raw) ? raw : (raw.data || raw);
  const uRec = arr.find(r=>r?.header?.parameterNumber===2);
  const vRec = arr.find(r=>r?.header?.parameterNumber===3);
  if (!uRec || !vRec) throw new Error('找不到 U/V 分量');

  const h = uRec.header;
  const nx=h.nx, ny=h.ny, lo1=h.lo1, la1=h.la1, dx=h.dx, dy=h.dy;
  const U=uRec.data, V=vRec.data;
  const bbox=[ lo1, la1 - ny*dy, lo1 + nx*dx, la1 ]; // [minLon,minLat,maxLon,maxLat]

  function bilerp(a00,a10,a01,a11, tx,ty){
    const a0=a00 + tx*(a10-a00);
    const a1=a01 + tx*(a11-a01);
    return a0 + ty*(a1-a0);
  }
  function sample(lon,lat){ // 回 {u,v} (m/s)，越界回 null
    const x=(lon-lo1)/dx - 0.5, y=(la1-lat)/dy - 0.5;
    if (x<0 || y<0 || x>nx-1 || y>ny-1) return null;
    const i0=Math.floor(x), j0=Math.floor(y);
    const i1=Math.min(i0+1,nx-1), j1=Math.min(j0+1,ny-1);
    const tx=x-i0, ty=y-j0;
    const idx=(jj,ii)=> jj*nx+ii;

    const u=bilerp(U[idx(j0,i0)],U[idx(j0,i1)],U[idx(j1,i0)],U[idx(j1,i1)], tx,ty);
    const v=bilerp(V[idx(j0,i0)],V[idx(j0,i1)],V[idx(j1,i0)],V[idx(j1,i1)], tx,ty); // 注意：v11索引
    return {u, v};
  }
  return { header:h, bbox, sample };
}

// ---- 粒子與尾跡資料結構 ----
const STATE = {
  field: null,
  headSrc: 'heads', headLyr: 'heads-lyr',
  trailSrc: 'trails', trailLyr: 'trails-lyr',
  timer: null,
  parts: [],          // {lon,lat, age, path:[{lon,lat},...]}
  geoHeads: { type:'FeatureCollection', features:[] },
  geoTrails: { type:'FeatureCollection', features:[] }
};

function ensureLayers(){
  if (!map.getSource(STATE.headSrc))
    map.addSource(STATE.headSrc, { type:'geojson', data: STATE.geoHeads });
  if (!map.getSource(STATE.trailSrc))
    map.addSource(STATE.trailSrc, { type:'geojson', data: STATE.geoTrails });

  if (!map.getLayer(STATE.trailLyr)){
    map.addLayer({
      id: STATE.trailLyr, type:'line', source: STATE.trailSrc, slot:'top',
      paint:{
        'line-color': ['interpolate',['linear'],['get','spd'],
          0,'#ffffff', 2,'#ffffff', 5,'#ffffff', 8,'#ffffff', 12,'#ffffff', 20,'#ffffff'],
        'line-width': 0.8,
        'line-opacity': 0.9
      },
      layout:{ 'line-cap':'round','line-join':'round' }
    });
  }
  if (!map.getLayer(STATE.headLyr)){
    map.addLayer({
      id: STATE.headLyr, type:'circle', source: STATE.headSrc, slot:'top',
      paint:{
        'circle-radius': ['interpolate',['linear'],['zoom'], 9,0.6, 12,0.6, 15,0.6],
        'circle-color':  '#ffffff',
        'circle-stroke-color':'#ffffff',
        'circle-stroke-width': 0.6,
        'circle-opacity': 1,
        'circle-pitch-alignment':'map'
      }
    });
  }
}

// 產生/重生
function spawn(n, bbox){
  const [minLon,minLat,maxLon,maxLat] = bbox;
  const MIN_SPAWN_SPD = 0.001;     // 太小會看不出動，優先避開
  const MAX_TRY = 12;

  STATE.parts = new Array(n).fill(0).map(()=> {
    let lon, lat, ok=false, tries=0;
    while(!ok && tries++ < MAX_TRY){
      lon = minLon + Math.random()*(maxLon-minLon);
      lat = minLat + Math.random()*(maxLat-minLat);
      const s = STATE.field?.sample(lon, lat);
      const spd = s ? Math.hypot(s.u, s.v) : 0;
      ok = spd >= MIN_SPAWN_SPD;
    }
    return { lon, lat, age: 300 + Math.floor(Math.random()*300), path: [] };
  });

  STATE.geoHeads.features = STATE.parts.map((p,idx)=>({
    type:'Feature', properties:{id:idx, spd:0},
    geometry:{type:'Point', coordinates:[p.lon,p.lat]}
  }));
  STATE.geoTrails.features = STATE.parts.map(()=>({
    type:'Feature', properties:{spd:0},
    geometry:{type:'LineString', coordinates:[]}
  }));

  map.getSource(STATE.headSrc).setData(STATE.geoHeads);
  map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
}

// 積分（RK2 中點）
function advectRK2(p, dtSec, field, gain = 1){
  const s1 = field.sample(p.lon, p.lat); 
  if (!s1) return null;

  let {u:u1, v:v1} = s1;                 // m/s
  if (DIR_IS_FROM){ u1 = -u1; v1 = -v1; }
  u1 *= gain; v1 *= gain;                // 視覺放大

  const metersPerDegLat = 111320;
  const metersPerDegLon1 = metersPerDegLat * Math.cos(p.lat * Math.PI/180);
  const dlon1 = (u1 * dtSec) / metersPerDegLon1;
  const dlat1 = (v1 * dtSec) / metersPerDegLat;

  const midLon = p.lon + 0.5 * dlon1, midLat = p.lat + 0.5 * dlat1;
  const s2 = field.sample(midLon, midLat); 
  if (!s2) return null;

  let {u:u2, v:v2} = s2;
  if (DIR_IS_FROM){ u2 = -u2; v2 = -v2; }
  u2 *= gain; v2 *= gain;

  const metersPerDegLon2 = metersPerDegLat * Math.cos(midLat * Math.PI/180);
  const dlon = (u2 * dtSec) / metersPerDegLon2;
  const dlat = (v2 * dtSec) / metersPerDegLat;

  return { lon: p.lon + dlon, lat: p.lat + dlat, spd: Math.hypot(u2,v2) };
}

// 主循環
function start(){
  stop();
  const count = +document.getElementById('count').value|0;
  spawn(count, STATE.field.bbox);

  // 立刻送一次資料並確保可見
  map.getSource(STATE.headSrc).setData(STATE.geoHeads);
  map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
  if (map.getLayer(STATE.headLyr))  map.setLayoutProperty(STATE.headLyr,  'visibility', 'visible');
  if (map.getLayer(STATE.trailLyr)) map.setLayoutProperty(STATE.trailLyr, 'visibility', 'visible');

  const tick = ()=>{
    const trailLen = +document.getElementById('trail').value|0;
    const speedMul = +document.getElementById('speed').value;
    const dtSec = 0.09;
    const zoomComp = 1;
    const gain = VISUAL_GAIN_BASE * speedMul * zoomComp;

    const [minLon,minLat,maxLon,maxLat] = STATE.field.bbox;
    const heads = STATE.geoHeads.features, trails = STATE.geoTrails.features;

    for (let i=0;i<STATE.parts.length;i++){
      let p = STATE.parts[i];
      const nxt = advectRK2(p, dtSec, STATE.field, gain);
      if (!nxt ||
          nxt.lon<minLon || nxt.lon>maxLon || nxt.lat<minLat || nxt.lat>maxLat ||
          --p.age<=0) {
        // 重生
        p.lon = minLon + Math.random()*(maxLon-minLon);
        p.lat = minLat + Math.random()*(maxLat-minLat);
        p.age = 300 + Math.floor(Math.random()*300);
        p.path.length = 0;
        heads[i].properties.spd = 0;
        heads[i].geometry.coordinates = [p.lon,p.lat];
        trails[i].properties.spd = 0;
        trails[i].geometry.coordinates = [];
        continue;
      }

      // 只有真的有移動才加到尾跡，避免重複點
      const dx = nxt.lon - p.lon, dy = nxt.lat - p.lat;
      const moved = Math.abs(dx) + Math.abs(dy);
      p.lon = nxt.lon; p.lat = nxt.lat;

      heads[i].properties.spd = nxt.spd;
      heads[i].geometry.coordinates = [p.lon, p.lat];

      if (moved > 1e-7) {
        p.path.push([p.lon, p.lat]);
        if (p.path.length>trailLen) p.path.shift();
        trails[i].properties.spd = nxt.spd;
        trails[i].geometry.coordinates = p.path;
      }
    }

    map.getSource(STATE.headSrc).setData(STATE.geoHeads);
    map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
  };

  // FPS
  STATE.timer = setInterval(tick, 90);
  map.on('dragstart.zoomstart', stop);
  map.on('dragend.zoomend', ()=>{ if(!STATE.timer) STATE.timer=setInterval(tick,90); });
}
function stop(){
  if (STATE.timer){ clearInterval(STATE.timer); STATE.timer=null; }
  map.off('dragstart.zoomstart', stop);
  map.off('dragend.zoomend', ()=>{});
}

// 載入指定情境並啟動
async function loadFieldAndStart(key){
  stop();
  const url = FILES[key];
  try{
    STATE.field = await loadUV(url);
    start();
  }catch(e){
    console.error('[loadField]', e);
    alert('讀取風場失敗：' + e.message);
  }
}
</script>
</body>
</html>
