<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>貼地風場流線（DJF/JJA × Day/Night）</title>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.14.0/mapbox-gl.js"></script>
<style>
  html,body,#map{height:100%;margin:0}
  .panel{position:absolute;left:12px;top:12px;z-index:5;background:rgba(255,255,255,.96);
         padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(0,0,0,.16);
         font:14px/1.5 system-ui,"Noto Sans TC";}
  .row{display:grid;grid-template-columns:92px 160px 52px;gap:8px;align-items:center;margin:6px 0}
  .row output{text-align:right;opacity:.8}
</style>
</head>
<body>
<div id="map"></div>

<div class="panel">
  <div style="font-weight:700;margin-bottom:6px">風場切換</div>
  <div>
    <label><input type="radio" name="season" value="DJF"> 冬季(DJF)</label>
    <label style="margin-left:10px"><input type="radio" name="season" value="JJA" checked> 夏季(JJA)</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="day" checked> 白天</label>
    <label style="margin-left:10px"><input type="radio" name="tod" value="night"> 夜晚</label>
  </div>

  <div style="font-weight:700;margin:8px 0 2px">參數</div>
  <div class="row">
    <label>粒子數</label>
    <input id="count" type="range" min="4000" max="40000" step="1000" value="15000">
    <output id="countV">15000</output>
  </div>
  <div class="row">
    <label>速度倍率</label>
    <input id="speed" type="range" min="0.8" max="2" step="0.1" value="1">
    <output id="speedV">1</output>
  </div>
  <div class="row">
    <label>尾跡長度</label>
    <input id="trail" type="range" min="2" max="10" step="1" value="5">
    <output id="trailV">5</output>
  </div>
</div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoidGVkbGl1IiwiYSI6ImNtMHAxMjdveDAwZWUya29sanY1c3Btc2EifQ.dGpYV4RZ4-OcpITjSKfcfg';
const STYLE_URL = 'mapbox://styles/tedliu/cm0qicaza00mf01pwfsfj3qgx';

// 視覺速度倍率：越大移動越明顯（建議 60~140）
const VISUAL_GAIN_BASE = 2000; 
// 顆數預設
const SURF_COUNT_DEFAULT = 15000;   // 原本 1200 → 2400
// 如果你有面板 slider，初始值一起改：<input id="count" ... value="2400">



// ---- 四份 native 風場檔 ----
const FILES = {
  DJF_day:   'wind_DJF_day_native.json',
  DJF_night: 'wind_DJF_night_native.json',
  JJA_day:   'wind_JJA_day_native.json',
  JJA_night: 'wind_JJA_night_native.json'
};
const DIR_IS_FROM = false; // 你的 native 角度/向量是「來向」，演算法會自動轉成「去向」

// ---- 地圖 ----
const map = new mapboxgl.Map({
  container: 'map',
  style: STYLE_URL,
  center: [121.0, 23.4],
  zoom: 8.5,
  pitch: 45,
  bearing: -8,
  antialias: true
});
map.setMinZoom(7);
map.setMaxZoom(14);

map.on('style.load', async () => {
  enableTerrain();
  ensureLayers();
  await map.once('idle');                // ★ 等地圖層級架好
  loadFieldAndStart(currentKey());
});


// 啟用 3D 地形
function enableTerrain(){
  const st = map.getStyle();
  const demEntry = Object.entries(st.sources).find(([,s])=>s.type==='raster-dem');
  if (demEntry) {
    map.setTerrain({ source: demEntry[0], exaggeration: 4 });
    if (!map.getLayer('sky')) map.addLayer({ id:'sky', type:'sky', paint:{'sky-type':'atmosphere'} });
  }
}

// ---- UI ----
function currentKey(){
  const s = document.querySelector('input[name="season"]:checked').value;
  const t = document.querySelector('input[name="tod"]:checked').value;
  return `${s}_${t}`;
}
document.querySelectorAll('input[name="season"],input[name="tod"]').forEach(el=>{
  el.addEventListener('change', ()=> loadFieldAndStart(currentKey()));
});
['count','speed','trail'].forEach(id=>{
  const el = document.getElementById(id), out = document.getElementById(id+'V');
  const fmt = v => (id==='count' ? v : (+v).toFixed(2));
  const upd = ()=> out.textContent = fmt(el.value);
  el.addEventListener('input', upd); upd();
});

// ---- 載入 native U/V → 可插值的場 ----
async function loadUV(url){
  const raw = await fetch(url, {cache:'no-cache'}).then(r=>{
    if(!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
    return r.json();
  });
  const arr = Array.isArray(raw) ? raw : (raw.data || raw);
  const uRec = arr.find(r=>r?.header?.parameterNumber===2);
  const vRec = arr.find(r=>r?.header?.parameterNumber===3);
  if (!uRec || !vRec) throw new Error('找不到 U/V 分量');

  const h = uRec.header;
  const nx=h.nx, ny=h.ny, lo1=h.lo1, la1=h.la1, dx=h.dx, dy=h.dy;
  const U=uRec.data, V=vRec.data;
  const bbox=[ lo1, la1 - ny*dy, lo1 + nx*dx, la1 ]; // [minLon,minLat,maxLon,maxLat]

  function bilerp(a00,a10,a01,a11, tx,ty){
    const a0=a00 + tx*(a10-a00);
    const a1=a01 + tx*(a11-a01);
    return a0 + ty*(a1-a0);
  }
  function sample(lon,lat){ // 回 {u,v} (m/s)，越界回 null
    const x=(lon-lo1)/dx - 0.5, y=(la1-lat)/dy - 0.5;
    if (x<0 || y<0 || x>nx-1 || y>ny-1) return null;
    const i0=Math.floor(x), j0=Math.floor(y);
    const i1=Math.min(i0+1,nx-1), j1=Math.min(j0+1,ny-1);
    const tx=x-i0, ty=y-j0;
    const idx=(jj,ii)=> jj*nx+ii;

    const u=bilerp(U[idx(j0,i0)],U[idx(j0,i1)],U[idx(j1,i0)],U[idx(j1,i1)], tx,ty);
    const v=bilerp(V[idx(j0,i0)],V[idx(j0,i1)],V[idx(j1,i0)],V[idx(j1,i1)], tx,ty);
    return {u, v};
  }
  return { header:h, bbox, sample };
}

// ---- 粒子與尾跡資料結構 ----
const STATE = {
  field: null,
  headSrc: 'heads', headLyr: 'heads-lyr',
  trailSrc: 'trails', trailLyr: 'trails-lyr',
  timer: null,
  parts: [],          // {lon,lat, age, path:[{lon,lat},...]}
  geoHeads: { type:'FeatureCollection', features:[] },
  geoTrails: { type:'FeatureCollection', features:[] }
};

function ensureLayers(){
  if (!map.getSource(STATE.headSrc))
    map.addSource(STATE.headSrc, { type:'geojson', data: STATE.geoHeads });
  if (!map.getSource(STATE.trailSrc))
    map.addSource(STATE.trailSrc, { type:'geojson', data: STATE.geoTrails });

  if (!map.getLayer(STATE.trailLyr)){
    map.addLayer({
      id: STATE.trailLyr, type:'line', source: STATE.trailSrc,
      slot: 'top',                 // ★ 放最上層（Mapbox GL JS v3）
      paint:{
        'line-color': ['interpolate',['linear'],['get','spd'],
          0,'#ffffff', 2,'#ffffff', 5,'#ffffff', 8,'#ffffff', 12,'#ffffff', 20,'#ffffff'],
        'line-width': 0.8,         // ★ 先放大，容易看到
        'line-opacity': 0.9
      },
      layout:{ 'line-cap':'round','line-join':'round' }
    });
  }
  if (!map.getLayer(STATE.headLyr)){
    map.addLayer({
      id: STATE.headLyr, type:'circle', source: STATE.headSrc,
      slot: 'top',                 // ★ 放最上層
      paint:{
        'circle-radius': ['interpolate',['linear'],['zoom'], 9,0.6, 12,0.6, 15,0.6], // ★ 放大
        'circle-color':  '#ffffff',
        'circle-stroke-color':'#ffffff',
        'circle-stroke-width': 0.6,
        'circle-opacity': 1,
        'circle-pitch-alignment':'map'
      }
    });
  }
}


// 產生/重生
function spawn(n, bbox){
  const [minLon,minLat,maxLon,maxLat] = bbox;
  const trailLen = +document.getElementById('trail').value|0;

  const MIN_SPAWN_SPD = 0.05;     // 低於 ~0.6 m/s 不太會動，盡量少放
  const MAX_TRY = 12;

  STATE.parts = new Array(n).fill(0).map(()=> {
    let lon, lat, ok=false, tries=0;
    while(!ok && tries++ < MAX_TRY){
      lon = minLon + Math.random()*(maxLon-minLon);
      lat = minLat + Math.random()*(maxLat-minLat);
      const s = STATE.field?.sample(lon, lat);
      const spd = s ? Math.hypot(s.u, s.v) : 0;
      ok = spd >= MIN_SPAWN_SPD;
    }
    return { lon, lat, age: 300 + Math.floor(Math.random()*300), path: [] };
  });

  STATE.geoHeads.features = STATE.parts.map((p,idx)=>({
    type:'Feature', properties:{id:idx, spd:0},
    geometry:{type:'Point', coordinates:[p.lon,p.lat]}
  }));
  STATE.geoTrails.features = STATE.parts.map(()=>({
    type:'Feature', properties:{spd:0},
    geometry:{type:'LineString', coordinates:[]}
  }));

  map.getSource(STATE.headSrc).setData(STATE.geoHeads);
  map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
}

// 積分（RK2 中點）
function advectRK2(p, dtSec, field, gain = 1){
  const s1 = field.sample(p.lon, p.lat); 
  if (!s1) return null;

  let {u:u1, v:v1} = s1;                 // m/s
  if (DIR_IS_FROM){ u1 = -u1; v1 = -v1; }
  u1 *= gain; v1 *= gain;                // ★ 放大視覺速度

  const metersPerDegLat = 111320;
  const metersPerDegLon1 = metersPerDegLat * Math.cos(p.lat * Math.PI/180);
  const dlon1 = (u1 * dtSec) / metersPerDegLon1;
  const dlat1 = (v1 * dtSec) / metersPerDegLat;

  const midLon = p.lon + 0.5 * dlon1, midLat = p.lat + 0.5 * dlat1;
  const s2 = field.sample(midLon, midLat); 
  if (!s2) return null;

  let {u:u2, v:v2} = s2;
  if (DIR_IS_FROM){ u2 = -u2; v2 = -v2; }
  u2 *= gain; v2 *= gain;                // ★ 放大視覺速度

  const metersPerDegLon2 = metersPerDegLat * Math.cos(midLat * Math.PI/180);
  const dlon = (u2 * dtSec) / metersPerDegLon2;
  const dlat = (v2 * dtSec) / metersPerDegLat;

  return { lon: p.lon + dlon, lat: p.lat + dlat, spd: Math.hypot(u2,v2) };
}


// 主循環
function start(){
  stop();
  const count = +document.getElementById('count').value|0;
  spawn(count, STATE.field.bbox);

  // ★ 立刻送一次資料並確保可見
  map.getSource(STATE.headSrc).setData(STATE.geoHeads);
  map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
  if (map.getLayer(STATE.headLyr))  map.setLayoutProperty(STATE.headLyr,  'visibility', 'visible');
  if (map.getLayer(STATE.trailLyr)) map.setLayoutProperty(STATE.trailLyr, 'visibility', 'visible');

  console.log('[start] parts:', STATE.parts.length, 'bbox:', STATE.field.bbox);

  const tick = ()=>{
    const trailLen = +document.getElementById('trail').value|0;
    const speedMul = +document.getElementById('speed').value;
    const dtSec = 0.09;                                   // 每幀「視覺秒數」
    // 可依縮放做些補償，讓不同 zoom 看起來速度相近（可先用固定 1）
    const zoomComp = 1; // Math.pow(2, map.getZoom() - 10) * 0.5;
    const gain = VISUAL_GAIN_BASE * speedMul * zoomComp;  // ★ 這就是放大倍率

    const [minLon,minLat,maxLon,maxLat] = STATE.field.bbox;
    const heads = STATE.geoHeads.features, trails = STATE.geoTrails.features;

    for (let i=0;i<STATE.parts.length;i++){
      let p = STATE.parts[i];
      const nxt = advectRK2(p, dtSec, STATE.field, gain); // ★ 帶入 gain
      if (!nxt ||
          nxt.lon<minLon || nxt.lon>maxLon || nxt.lat<minLat || nxt.lat>maxLat ||
          --p.age<=0) {
        // 重生
        p.lon = minLon + Math.random()*(maxLon-minLon);
        p.lat = minLat + Math.random()*(maxLat-minLat);
        p.age = 300 + Math.floor(Math.random()*300);
        p.path.length = 0;
        heads[i].properties.spd = 0;
        heads[i].geometry.coordinates = [p.lon,p.lat];
        trails[i].properties.spd = 0;
        trails[i].geometry.coordinates = [];
        continue;
      }

      // 只有真的有移動才加到尾跡，避免重複點
      const dx = nxt.lon - p.lon, dy = nxt.lat - p.lat;
      const moved = Math.abs(dx) + Math.abs(dy);
      p.lon = nxt.lon; p.lat = nxt.lat;

      heads[i].properties.spd = nxt.spd;
      heads[i].geometry.coordinates = [p.lon, p.lat];

      if (moved > 1e-7) {                 // ★ 約 10^-7 度 ≈ 幾公尺
        p.path.push([p.lon, p.lat]);
        if (p.path.length>trailLen) p.path.shift();
        trails[i].properties.spd = nxt.spd;
        trails[i].geometry.coordinates = p.path;
      }
    }

    map.getSource(STATE.headSrc).setData(STATE.geoHeads);
    map.getSource(STATE.trailSrc).setData(STATE.geoTrails);
  };


  // 以 setInterval 控 FPS（更穩定）
  STATE.timer = setInterval(tick, 90);
  // 拖地圖時先暫停、結束再恢復（更順眼）
  map.on('dragstart.zoomstart', stop);
  map.on('dragend.zoomend', ()=>{ if(!STATE.timer) STATE.timer=setInterval(tick,90); });
}
function stop(){
  if (STATE.timer){ clearInterval(STATE.timer); STATE.timer=null; }
  map.off('dragstart.zoomstart', stop);
  map.off('dragend.zoomend', ()=>{});
}

// 載入指定情境並啟動
async function loadFieldAndStart(key){
  stop();
  const url = FILES[key];
  try{
    STATE.field = await loadUV(url);
    start();
  }catch(e){
    console.error('[loadField]', e);
    alert('讀取風場失敗：' + e.message);
  }
}
</script>
</body>
</html>
